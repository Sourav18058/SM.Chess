<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game ‚Äî Tarun vs Bipasa</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* Character Selection Screen */
        #selection-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            animation: fadeIn 0.5s;
        }

        #selection-screen h1 {
            font-size: 2.5em;
            margin-bottom: 30px;
            color: #333;
        }

        .player-options {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        .player-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 30px;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            color: white;
            min-width: 200px;
        }

        .player-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .player-card.male {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .player-card .icon {
            font-size: 4em;
            margin-bottom: 10px;
        }

        .player-card h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .player-card p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* Game Screen */
        #game-screen {
            display: none;
            animation: fadeIn 0.5s;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }

        .player-name {
            font-size: 1.3em;
            font-weight: bold;
        }

        .player-score {
            font-size: 0.9em;
            opacity: 0.9;
            margin-top: 5px;
        }

        .turn-indicator {
            background: rgba(255,255,255,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .score-container {
            text-align: center;
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            gap: 0;
            border: 3px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin: 20px auto;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 45px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #baca44 !important;
        }

        .square.possible-move {
            background-color: #7fc97f !important;
        }

        .square.possible-move::after {
            content: '';
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            position: absolute;
        }

        .square.last-move-from {
            background-color: #f7dc6f !important;
            animation: moveHighlight 1s ease-in-out;
        }

        .square.last-move-to {
            background-color: #f39c12 !important;
            animation: moveHighlight 1s ease-in-out;
        }

        .square.moving-piece {
            animation: pieceMove 0.5s ease-in-out;
        }

        @keyframes moveHighlight {
            0% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.7);
            }
            50% {
                box-shadow: 0 0 0 20px rgba(243, 156, 18, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0);
            }
        }

        @keyframes pieceMove {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3) rotate(5deg);
            }
            100% {
                transform: scale(1);
            }
        }

        .square:hover {
            opacity: 0.8;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .restart-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .undo-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        #status {
            text-align: center;
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            min-height: 30px;
        }

        .thinking-indicator {
            text-align: center;
            margin-top: 10px;
            font-size: 1em;
            color: #667eea;
            font-style: italic;
        }

        .check-warning {
            background: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        footer {
            margin-top: 30px;
            text-align: center;
            color: white;
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @media (max-width: 768px) {
            #chessboard {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }

            .square {
                width: 45px;
                height: 45px;
                font-size: 30px;
            }

            .player-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="selection-screen">
        <h1>üéÆ Choose Your Player</h1>
        <div class="player-options">
            <div class="player-card male" onclick="selectPlayer('tarun')">
                <div class="icon">üë¶</div>
                <h2>Tarun</h2>
                <p>Play as White</p>
            </div>
            <div class="player-card" onclick="selectPlayer('bipasa')">
                <div class="icon">üë©</div>
                <h2>Bipasa</h2>
                <p>Play as Black</p>
            </div>
        </div>
    </div>

    <div id="game-screen">
        <div class="game-container">
            <div class="player-info">
                <div class="score-container">
                    <div class="player-name" id="computer-name">Computer</div>
                    <div class="player-score" id="computer-score">Wins: 0</div>
                </div>
                <div class="turn-indicator" id="turn-indicator">White's Turn</div>
                <div class="score-container">
                    <div class="player-name" id="player-name">Player</div>
                    <div class="player-score" id="player-score">Wins: 0</div>
                </div>
            </div>
            
            <div id="chessboard"></div>
            
            <div id="thinking-indicator" class="thinking-indicator" style="display: none;">ü§î Computer is thinking...</div>
            <div id="check-warning" class="check-warning" style="display: none;"></div>
            <div id="status"></div>
            
            <div class="controls">
                <button class="restart-btn" onclick="restartGame()">üîÑ Restart</button>
                <button class="undo-btn" onclick="undoMove()">‚Ü©Ô∏è Undo</button>
            </div>
        </div>
    </div>

    <footer>
        <p>Developed by Sourav Mondal</p>
    </footer>

    <script>
        // Game State
        let board = [];
        let selectedPiece = null;
        let selectedSquare = null;
        let currentTurn = 'white';
        let playerColor = 'white';
        let playerName = '';
        let moveHistory = [];
        let gameOver = false;
        let playerWins = 0;
        let computerWins = 0;

        // Chess piece Unicode symbols
        const pieces = {
            white: {
                king: '‚ôî',
                queen: '‚ôï',
                rook: '‚ôñ',
                bishop: '‚ôó',
                knight: '‚ôò',
                pawn: '‚ôô'
            },
            black: {
                king: '‚ôö',
                queen: '‚ôõ',
                rook: '‚ôú',
                bishop: '‚ôù',
                knight: '‚ôû',
                pawn: '‚ôü'
            }
        };

        function selectPlayer(player) {
            if (player === 'tarun') {
                playerName = 'Tarun';
                playerColor = 'white';
            } else {
                playerName = 'Bipasa';
                playerColor = 'black';
            }
            
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            document.getElementById('player-name').textContent = `Player: ${playerName}`;
            
            updateScoreDisplay();
            initializeBoard();
            renderBoard();
            
            if (playerColor === 'black') {
                setTimeout(makeComputerMove, 2000);
            }
        }

        function initializeBoard() {
            board = [
                [{type: 'rook', color: 'black'}, {type: 'knight', color: 'black'}, {type: 'bishop', color: 'black'}, {type: 'queen', color: 'black'}, {type: 'king', color: 'black'}, {type: 'bishop', color: 'black'}, {type: 'knight', color: 'black'}, {type: 'rook', color: 'black'}],
                [{type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}, {type: 'pawn', color: 'black'}],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [{type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}, {type: 'pawn', color: 'white'}],
                [{type: 'rook', color: 'white'}, {type: 'knight', color: 'white'}, {type: 'bishop', color: 'white'}, {type: 'queen', color: 'white'}, {type: 'king', color: 'white'}, {type: 'bishop', color: 'white'}, {type: 'knight', color: 'white'}, {type: 'rook', color: 'white'}]
            ];
            currentTurn = 'white';
            moveHistory = [];
            gameOver = false;
            updateTurnIndicator();
        }

        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece.color][piece.type];
                    }
                    
                    square.onclick = () => handleSquareClick(row, col);
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentTurn !== playerColor) return;
            
            const clickedPiece = board[row][col];
            
            if (selectedPiece) {
                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    if (!wouldBeInCheck(selectedSquare.row, selectedSquare.col, row, col, playerColor)) {
                        makeMove(selectedSquare.row, selectedSquare.col, row, col);
                        clearHighlights();
                        selectedPiece = null;
                        selectedSquare = null;
                        
                        if (!gameOver) {
                            document.getElementById('thinking-indicator').style.display = 'block';
                            setTimeout(makeComputerMove, 2000);
                        }
                    } else {
                        document.getElementById('status').textContent = '‚ö†Ô∏è Invalid move! Your King would be in check!';
                        setTimeout(() => {
                            document.getElementById('status').textContent = '';
                        }, 2000);
                    }
                } else if (clickedPiece && clickedPiece.color === playerColor) {
                    clearHighlights();
                    selectPiece(row, col);
                } else {
                    clearHighlights();
                    selectedPiece = null;
                    selectedSquare = null;
                }
            } else if (clickedPiece && clickedPiece.color === playerColor) {
                selectPiece(row, col);
            }
        }

        function selectPiece(row, col) {
            selectedPiece = board[row][col];
            selectedSquare = {row, col};
            highlightSquare(row, col);
            highlightPossibleMoves(row, col);
        }

        function highlightSquare(row, col) {
            const squares = document.querySelectorAll('.square');
            squares[row * 8 + col].classList.add('selected');
        }

        function highlightPossibleMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const squares = document.querySelectorAll('.square');
                        squares[r * 8 + c].classList.add('possible-move');
                    }
                }
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move');
            });
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece || piece.color !== currentTurn) return false;
            if (targetPiece && targetPiece.color === piece.color) return false;
            
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            
            switch (piece.type) {
                case 'pawn':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, piece.color);
                case 'rook':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'knight':
                    return isValidKnightMove(rowDiff, colDiff);
                case 'bishop':
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'queen':
                    return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                case 'king':
                    return isValidKingMove(rowDiff, colDiff);
                default:
                    return false;
            }
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            if (colDiff === 0 && !board[toRow][toCol]) {
                if (rowDiff === direction) return true;
                if (fromRow === startRow && rowDiff === 2 * direction && !board[fromRow + direction][fromCol]) return true;
            }
            
            if (colDiff === 1 && rowDiff === direction && board[toRow][toCol] && board[toRow][toCol].color !== color) {
                return true;
            }
            
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidKnightMove(rowDiff, colDiff) {
            return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) || 
                   (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(rowDiff, colDiff) {
            return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            moveHistory.push({
                from: {row: fromRow, col: fromCol},
                to: {row: toRow, col: toCol},
                piece: board[fromRow][fromCol],
                capturedPiece: board[toRow][toCol]
            });
            
            const capturedPiece = board[toRow][toCol];
            const movingPiece = board[fromRow][fromCol];
            
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            
            // Check if king was captured
            if (capturedPiece && capturedPiece.type === 'king') {
                gameOver = true;
                if (capturedPiece.color === playerColor) {
                    computerWins++;
                    document.getElementById('status').textContent = 'üëë Checkmate! Computer captured your King and wins!';
                } else {
                    playerWins++;
                    document.getElementById('status').textContent = 'üéâ Checkmate! You captured the King and win!';
                }
                updateScoreDisplay();
                renderBoard();
                document.getElementById('thinking-indicator').style.display = 'none';
                return;
            }
            
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            renderBoard();
            updateTurnIndicator();
            checkForCheck();
            checkGameOver();
        }

        function makeComputerMove() {
            if (gameOver) return;
            
            const moves = getAllValidMoves(currentTurn);
            const validMoves = moves.filter(move => 
                !wouldBeInCheck(move.from.row, move.from.col, move.to.row, move.to.col, currentTurn)
            );
            
            if (validMoves.length === 0) {
                gameOver = true;
                playerWins++;
                document.getElementById('status').textContent = 'üéâ Checkmate! You win!';
                updateScoreDisplay();
                document.getElementById('thinking-indicator').style.display = 'none';
                return;
            }
            
            let bestMove = validMoves[0];
            let bestScore = -Infinity;
            
            for (const move of validMoves) {
                let score = 0;
                if (move.capturedPiece) {
                    score = getPieceValue(move.capturedPiece.type) * 10;
                }
                score += Math.random();
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            makeMove(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
            document.getElementById('thinking-indicator').style.display = 'none';
        }

        function getAllValidMoves(color) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.color === color) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({
                                        from: {row: fromRow, col: fromCol},
                                        to: {row: toRow, col: toCol},
                                        capturedPiece: board[toRow][toCol]
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function getPieceValue(type) {
            const values = {pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 100};
            return values[type] || 0;
        }

        function checkGameOver() {
            const opponentColor = currentTurn;
            const moves = getAllValidMoves(opponentColor);
            const validMoves = moves.filter(move => 
                !wouldBeInCheck(move.from.row, move.from.col, move.to.row, move.to.col, opponentColor)
            );
            
            if (validMoves.length === 0) {
                gameOver = true;
                if (opponentColor === playerColor) {
                    computerWins++;
                    document.getElementById('status').textContent = '‚ùå Checkmate! Computer wins!';
                } else {
                    playerWins++;
                    document.getElementById('status').textContent = 'üéâ Checkmate! You win!';
                }
                updateScoreDisplay();
            }
        }

        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return {row, col};
                    }
                }
            }
            return null;
        }

        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === byColor) {
                        if (isValidMove(r, c, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isInCheck(color) {
            const king = findKing(color);
            if (!king) return false;
            
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(king.row, king.col, opponentColor);
        }

        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            const originalPiece = board[toRow][toCol];
            const movingPiece = board[fromRow][fromCol];
            
            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;
            
            const inCheck = isInCheck(color);
            
            board[fromRow][fromCol] = movingPiece;
            board[toRow][toCol] = originalPiece;
            
            return inCheck;
        }

        function checkForCheck() {
            const checkWarning = document.getElementById('check-warning');
            
            if (isInCheck(currentTurn)) {
                checkWarning.style.display = 'block';
                checkWarning.textContent = `‚ö†Ô∏è CHECK! ${currentTurn === 'white' ? 'White' : 'Black'} King is under attack!`;
            } else {
                checkWarning.style.display = 'none';
            }
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-indicator');
            indicator.textContent = currentTurn === 'white' ? "White's Turn" : "Black's Turn";
        }

        function updateScoreDisplay() {
            document.getElementById('player-score').textContent = `Wins: ${playerWins}`;
            document.getElementById('computer-score').textContent = `Wins: ${computerWins}`;
        }

        function undoMove() {
            if (moveHistory.length === 0 || gameOver) return;
            
            const lastMove = moveHistory.pop();
            board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            board[lastMove.to.row][lastMove.to.col] = lastMove.capturedPiece;
            
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            
            if (moveHistory.length > 0 && currentTurn !== playerColor) {
                const secondLastMove = moveHistory.pop();
                board[secondLastMove.from.row][secondLastMove.from.col] = secondLastMove.piece;
                board[secondLastMove.to.row][secondLastMove.to.col] = secondLastMove.capturedPiece;
                currentTurn = currentTurn === 'white' ? 'black' : 'white';
            }
            
            gameOver = false;
            document.getElementById('status').textContent = '';
            document.getElementById('check-warning').style.display = 'none';
            document.getElementById('thinking-indicator').style.display = 'none';
            renderBoard();
            updateTurnIndicator();
            checkForCheck();
        }

        function restartGame() {
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('selection-screen').style.display = 'block';
        }
    </script>
</body>
</html>
